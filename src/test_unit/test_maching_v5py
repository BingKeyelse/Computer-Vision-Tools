import cv2
import numpy as np
import matplotlib.pyplot as plt

# Ảnh gốc và ảnh cần so khớp
img1 = cv2.imread(r"src\data\sample\sample.jpg", 0)
img2 = cv2.imread(r"src\data\sample\6.jpg", 0)

# ORB detector
orb = cv2.ORB_create(1000)
kp1, des1 = orb.detectAndCompute(img1, None)
kp2, des2 = orb.detectAndCompute(img2, None)

# Matcher
bf = cv2.BFMatcher(cv2.NORM_HAMMING)
matches = bf.knnMatch(des1, des2, k=2)

# Lowe's ratio test
good = []
for m,n in matches:
    if m.distance < 0.75*n.distance:
        good.append(m)

print(len(good))

if len(good) >= 5:

    good = sorted(good, key=lambda x: x.distance)[:10]
    src_pts = np.float32([kp1[m.queryIdx].pt for m in good]).reshape(-1,1,2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good]).reshape(-1,1,2)

    # Tính affine transform (chỉ xoay + dịch + scale)
    M, inliers = cv2.estimateAffinePartial2D(src_pts, dst_pts, method=cv2.RANSAC)

    if M is not None:
        # Lấy rotation + dịch
        R = M[:2,:2]
        t = M[:,2]

        # Góc xoay
        angle = np.degrees(np.arctan2(R[1,0], R[0,0]))
        print("Rotation matrix:\n", R)
        print("Translation:", t)
        print("Rotation angle:", angle)

        # Vẽ bounding box
        h,w = img1.shape
        pts = np.float32([[0,0],[w,0],[w,h],[0,h]]).reshape(-1,1,2)
        dst_box = cv2.transform(pts, M)

        img2_color = cv2.cvtColor(img2, cv2.COLOR_GRAY2BGR)
        cv2.polylines(img2_color, [np.int32(dst_box)], True, (0,255,0), 3)

        matched_img = cv2.drawMatches(img1, kp1, img2_color, kp2, good, None,
                                      flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)

        plt.figure(figsize=(14,7))
        plt.imshow(matched_img[...,::-1])  # chuyển sang RGB
        plt.axis("off")
        plt.show()
    else:
        print("Không tính được affine transform")
else:
    print("Không đủ matches")
